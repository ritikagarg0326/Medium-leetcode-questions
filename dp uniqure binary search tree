Unique Binary Search Trees

Given an integer n, return the number of structurally unique BST's (binary search trees) which has exactly n nodes of unique values from 1 to n.

Example 1:


Input: n = 3
Output: 5
Problem Explanation:
The task is to calculate the number of unique binary search trees (BSTs) that can be formed using n unique values from 1 to n. A binary search tree is defined by its properties, where the left subtree contains values less than the root and the right subtree contains values greater than the root.

Approach:
There are two main ways to solve this problem:

Brute Force: Generate all unique BSTs for the given n and count them.
Dynamic Programming (Optimized): Use the Catalan number formula, which efficiently counts the number of unique BSTs using previously computed results.
Solution 1: Brute Force
In the brute-force approach, we recursively generate all possible BSTs for every root and calculate the number of trees for each configuration.

Time Complexity:
Time: 
ùëÇ
(
2
ùëõ
)
O(2 
n
 ) in the worst case due to the exponential growth of the tree structures being generated.
Space: 
ùëÇ
(
ùëõ
)
O(n) for the recursion stack.
Brute Force Code:
python
Copy code
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def generate_trees(n):
    if n == 0:
        return []
    
    def build_trees(start, end):
        if start > end:
            return [None]
        
        all_trees = []
        for i in range(start, end + 1):
            # Generate all left and right subtrees
            left_trees = build_trees(start, i - 1)
            right_trees = build_trees(i + 1, end)
            
            # Connect left and right trees to the root (i)
            for left in left_trees:
                for right in right_trees:
                    root = TreeNode(i)
                    root.left = left
                    root.right = right
                    all_trees.append(root)
        
        return all_trees
    
    return build_trees(1, n)

def num_trees(n):
    return len(generate_trees(n))

# Example input
n = 3
# Output
print(num_trees(n))  # Output: 5
Explanation of Brute Force Solution:
TreeNode Class:

A standard binary tree node definition.
generate_trees Function:

If n is 0, return an empty list.
The inner function build_trees generates all possible BSTs within the range from start to end.
For each possible root i in the range, it generates all left and right subtrees recursively and connects them to the root i.
Finally, it returns all possible trees for the range.
num_trees Function:

It simply counts the number of unique BSTs generated by the generate_trees function.
Solution 2: Dynamic Programming (Optimized)
The optimized solution uses dynamic programming to compute the number of unique BSTs. The key insight is that for each number i chosen as the root, the left subtree can have i-1 nodes and the right subtree can have n-i nodes. Therefore, the number of unique trees is a combination of the unique trees formed from the left and right subtrees.

Time Complexity:
Time: 
ùëÇ
(
ùëõ
2
)
O(n 
2
 ), because we fill up an array with values derived from previous computations in a nested manner.
Space: 
ùëÇ
(
ùëõ
)
O(n) for storing the results in a DP array.
Optimized Code:
python
Copy code
def num_trees(n):
    # dp[i] will store the number of unique BSTs with i nodes
    dp = [0] * (n + 1)
    dp[0], dp[1] = 1, 1  # Base cases: 1 tree for 0 or 1 nodes
    
    for nodes in range(2, n + 1):
        for root in range(1, nodes + 1):
            # left_subtrees = dp[root - 1], right_subtrees = dp[nodes - root]
            dp[nodes] += dp[root - 1] * dp[nodes - root]
    
    return dp[n]

# Example input
n = 3
# Output
print(num_trees(n))  # Output: 5
Explanation of Optimized Solution:
Dynamic Programming Array (dp):

dp[i] represents the number of unique BSTs that can be formed with i nodes.
Base Cases:

dp[0] and dp[1] are both 1, representing that there is one way to arrange zero or one node.
Filling the DP Table:

For each number of nodes from 2 to n, we calculate the number of unique BSTs.
For each possible root (from 1 to nodes), the number of unique trees is the product of the number of unique trees formed from the left and right subtrees.
The left subtree has root - 1 nodes, and the right subtree has nodes - root.
Final Output:

The function returns dp[n], which contains the total number of unique BSTs that can be formed using n nodes.
Conclusion:
The brute-force solution is straightforward but inefficient for larger values of n due to its exponential time complexity.
The dynamic programming solution is efficient, reducing the time complexity to 
ùëÇ
(
ùëõ
2
)
O(n 
2
 ), making it suitable for 
ùëõ
n up to 
19
19 as per the problem constraints.
